
"-----------------------------------------------------------------------------
" general
"-----------------------------------------------------------------------------
set nocompatible        " use vim as vim, should be put at the very start
set history=100         " lines of Ex-mode commands, search history
set browsedir=buffer    " use directory of the related buffer for file browser
set clipboard+=unnamed  " use clipboard register '*' for all y, d, c, p ops
set viminfo+=!          " make sure it can save viminfo
set isk+=$,%,#,-,@,_    " none of these should be word dividers
set confirm             " raise a dialog confirm whether save changed buffer
set ffs=unix,dos,mac    " favor unix, which behaves good under Linux/Windows
set fenc=utf-8          " default fileencoding
set fencs=utf-8,ucs-bom,euc-jp,gb18030,gbk,gb2312,cp936
map Q gq
                        " do not use Ex-mode, use Q for formatting
filetype on             " enable file type detection
filetype plugin on      " enable loading the plugin for appropriate file type

"-----------------------------------------------------------------------------
" colors
"-----------------------------------------------------------------------------
"colorscheme evening
colorscheme slate
set background=dark     " use a dark background
"set background=darkblue     " use a dark background
syntax on               " syntax highlighting

"-----------------------------------------------------------------------------
" gui-only settings
"-----------------------------------------------------------------------------
if has("gui_running")
"  colo inkpot           " colorscheme, inkpot.vim
  set lines=35          " window tall and wide, only if gui_running,
  set columns=105       " or vim under console behaves badly
endif

"-----------------------------------------------------------------------------
" Vim UI
"-----------------------------------------------------------------------------
set linespace=1         " space it out a little more (easier to read)
set wildmenu            " type :h and press <Tab> to look what happens
set ruler               " always show current position along the bottom
set cmdheight=2         " use 2 screen lines for command-line
set lazyredraw          " do not redraw while executing macros (much faster)
set number              " don't print line number
set hid                 " allow to change buffer without saving
set backspace=2         " make backspace work normal
set whichwrap+=<,>,h,l  " allow backspace and cursor keys to wrap
"set mouse=a             " use mouse in all modes
set shortmess=atI       " shorten messages to avoid 'press a key' prompt
set report=0            " tell us when anything is changed via :...
set fillchars=vert:\ ,stl:\ ,stlnc:\
                        " make the splitters between windows be blank

"-----------------------------------------------------------------------------
" visual cues
"-----------------------------------------------------------------------------
set showmatch           " show matching paren
set matchtime=5         " 1/10 second to show the matching paren
set hlsearch            " do not highlight searched for phrases
set incsearch           " BUT do highlight where the typed pattern matches
set scrolloff=3         " minimal number of screen lines to keep above/below the cursor
set novisualbell        " use visual bell instead of beeping
set noerrorbells        " do not make noise
set laststatus=2        " always show the status line
set listchars=tab:\|\ ,trail:.,extends:>,precedes:<,eol:$ " how :set list show
"set statusline=%{VimBuddy()}\ %F%m%r%h%w\ [%{&ff}]\ [%Y]\ [\%03.3b\ \%02.2B]\ [%02v\ %03l\ %L\ %p%%]
                        " need vimbuddy.vim, dislike it? just remove it

"-----------------------------------------------------------------------------
" text formatting/layout
"-----------------------------------------------------------------------------
set ai                  " autoindent
set si                  " smartindent
set cindent             " do C-style indenting
set fo=tcrqn            " see help (complex)
set tabstop=2           " tab spacing
set softtabstop=2       " unify it
set shiftwidth=2        " unify it
set expandtab         " real tabs please!
set smarttab            " use tabs at the start of a line, spaces elsewhere
set wrap                " do not wrap lines
set formatoptions+=mM   " thus vim can reformat multibyte text (e.g. Chinese)

" When editing a file, always jump to the last known cursor position. 
" Don't do it when the position is invalid or when inside an event handler 
" (happens when dropping a file on gvim). 
autocmd BufReadPost * 
\ if line("'\"") > 0 && line("'\"") <= line("$") | 
\ exe "normal g`\"" | 
\ endif 

"-----------------------------------------------------------------------------
" folding
"-----------------------------------------------------------------------------
"set foldenable          " turn on folding
"set foldmethod=indent   " make folding indent sensitive
"set foldlevel=100       " don't autofold anything, but can still fold manually
"set foldopen -=search   " don't open folds when you search into them
"set foldopen -=undo     " don't open folds when you undo stuff

"set guifont=Monospace\ 11
"set guifont=Liberation_Mono:h12:cANSI
"set guifont=Arial_monospaced_for_SAP:h9:cANSI

set wildmode=list:longest
set tags=~/workspace/procise_team/tags
set ic

set clipboard=unnamed
"tab navigation
nnoremap <C-n> :tabnew 
nnoremap <C-p> :sp 

nnoremap <C-s> :wq<CR>  
vnoremap <C-s> <ESC>:wq<CR>  
inoremap <C-s> <ESC>:wq<CR>  

nnoremap <C-d> :q!<CR>  
vnoremap <C-d> <ESC>:q!<CR>  
inoremap <C-d> <ESC>:q!<CR>  

nnoremap <C-g>  /goto<CR>
vnoremap <C-g> <ESC>/goto<CR>  
inoremap <C-g> <ESC>/goto<CR>

nnoremap <C-r> <C-r>  
vnoremap <C-r> <ESC><C-r>  
inoremap <C-r> <ESC><C-r>  

nnoremap <C-u> u
vnoremap <C-u> <ESC>u  
inoremap <C-u> <ESC>u  

"nnoremap <C-i> :set ignorecase smartcase<CR>  
"vnoremap <C-i> <ESC>set ignorecase smartcase<CR>  
"inoremap <C-i> <ESC>set ignorecase smartcase<CR>  

nnoremap <C-c> "+y<CR>  
vnoremap <C-c> <ESC>"+y<CR>  
inoremap <C-c> <ESC>"+y<CR>  

nnoremap <C-left> <ESC>:tabprevious<CR>  
vnoremap <C-left> <ESC>:tabprevious<CR>  
inoremap <C-left> <ESC>:tabprevious<CR>  
nnoremap <C-right> <ESC>:tabnext<CR>  
vnoremap <C-right> <ESC>:tabnext<CR>  
inoremap <C-right> <ESC>:tabnext<CR>  
nnoremap <C-up> <ESC><C-w>k 
vnoremap <C-up> <ESC><C-w>k
inoremap <C-up> <ESC><C-w>k
nnoremap <C-down> <ESC><C-w>j
vnoremap <C-down> <ESC><C-w>j
inoremap <C-down> <ESC><C-w>j

nnoremap <S-up> <ESC>:res +1<CR>  
vnoremap <S-up> <ESC>:res +1<CR>  
inoremap <S-up> <ESC>:res +1<CR>  
nnoremap <S-down> <ESC>:res -1<CR>  
vnoremap <S-down> <ESC>:res -1<CR>  
inoremap <S-down> <ESC>:res -1<CR>
nnoremap <S-left> <ESC>:vertical res +1<CR>
vnoremap <S-left> <ESC>:vertical res +1<CR>
inoremap <S-left> <ESC>:vertical res +1<CR>
nnoremap <S-right> <ESC>:vertical res -1<CR>  
vnoremap <S-right> <ESC>:vertical res -1<CR>
inoremap <S-right> <ESC>:vertical res -1<CR>

nnoremap <S-k> <ESC><C-w>k  
vnoremap <S-k> <ESC><C-w>k  
inoremap <S-k> <ESC><C-w>k  
nnoremap <S-j> <ESC><C-w>j  
vnoremap <S-j> <ESC><C-w>j  
inoremap <S-j> <ESC><C-w>j
nnoremap <S-h> <ESC><C-w>h
vnoremap <S-h> <ESC><C-w>h
inoremap <S-h> <ESC><C-w>h
nnoremap <S-l> <ESC><C-w>l  
vnoremap <S-l> <ESC><C-w>l
inoremap <S-l> <ESC><C-w>l

nnoremap <A-up>    <ESC><C-w>k  
vnoremap <A-up>    <ESC><C-w>k  
inoremap <A-up>    <ESC><C-w>k  
nnoremap <A-down>  <ESC><C-w>j  
vnoremap <A-down>  <ESC><C-w>j  
inoremap <A-down>  <ESC><C-w>j
nnoremap <A-left>  <ESC><C-w>h
vnoremap <A-left>  <ESC><C-w>h
inoremap <A-left>  <ESC><C-w>h
nnoremap <A-right> <ESC><C-w>l  
vnoremap <A-right> <ESC><C-w>l
inoremap <A-right> <ESC><C-w>l

nnoremap <C-a> ggVG  
vnoremap <C-a> <ESC>ggVG  
inoremap <C-a> <ESC>ggVG  
"inoremap <Tab> <C-N>
nnoremap <ESC><ESC> <ESC>:w<CR>
vnoremap <ESC><ESC> <ESC>:w<CR>
inoremap <ESC><ESC> <ESC>:w<CR>
"nnoremap `` <ESC>:w<CR>:!mkg<CR>
"vnoremap `` <ESC>:w<CR>:!mkg<CR>
"inoremap `` <ESC>:w<CR>:!mkg<CR>
inoremap ` <C-N>
inoremap ( ()<ESC>i
inoremap ) <c-r>=ClosePair(')')<CR>
inoremap [ []<ESC>i
inoremap ] <c-r>=ClosePair(']')<CR>
inoremap { {}<ESC>i
inoremap } <c-r>=ClosePair('}')<CR>
inoremap "" ""<ESC>i
inoremap '' ''<ESC>i
function ClosePair(char)
    if getline('.')[col('.') - 1] == a:char
        return "\<Right>"
    else
        return a:char
    endif
endfunction
inoremap H H
inoremap L L
inoremap K K
inoremap J J
"inoremap DD <Delete>
"inoremap HH <left>
"inoremap LL <right>
"inoremap KK <up>
"inoremap JJ <down>
"inoremap HHH HH 
"inoremap LLL LL
"inoremap KKK KK
"inoremap JJJ JJ
inoremap UU <ESC>uI
inoremap RR <ESC><C-r>I
nnoremap <F2> gf<C-o>:sp #<CR>
nnoremap <F3> gf<C-o>:sp #<CR>

vnoremap <C-c> "+y
"inoremap <C-v> <MiddleMouse>
